---
phase: 09-content-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/updates.ts
  - next.config.ts
autonomous: true

must_haves:
  truths:
    - "Markdown files in src/content/updates/ are parsed into typed UpdateEntry objects with frontmatter and rendered HTML body"
    - "TypeScript compilation fails if an entry uses an invalid tag or is missing required frontmatter fields"
    - "getUpdates() returns entries sorted newest-first and uses the 'use cache' directive for build-time caching"
  artifacts:
    - path: "src/lib/updates.ts"
      provides: "UpdateEntry type, UpdateTag union, getUpdates(), parseUpdate()"
      exports: ["UpdateEntry", "UpdateTag", "UPDATE_TAGS", "getUpdates"]
    - path: "next.config.ts"
      provides: "cacheComponents enabled for 'use cache' directive"
      contains: "cacheComponents: true"
  key_links:
    - from: "src/lib/updates.ts"
      to: "src/content/updates/*.md"
      via: "fs/promises readdir + readFile"
      pattern: "readdir|readFile"
    - from: "src/lib/updates.ts"
      to: "gray-matter"
      via: "frontmatter extraction"
      pattern: "matter\\("
    - from: "src/lib/updates.ts"
      to: "unified pipeline"
      via: "markdown to HTML conversion"
      pattern: "unified\\(\\)|remark|rehype"
---

<objective>
Build the typed markdown content pipeline that reads update entries from disk, parses frontmatter with gray-matter, renders markdown body to HTML with unified/remark/rehype, and returns typed UpdateEntry objects sorted newest-first with build-time caching.

Purpose: This is the data layer for the entire /updates feature -- every downstream phase (page shell, cards, filtering) depends on this pipeline existing and returning correct typed data.
Output: src/lib/updates.ts with all types, validation, and parsing logic; next.config.ts updated for "use cache" support.
</objective>

<execution_context>
@/Users/lucasalexander/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucasalexander/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-content-infrastructure/09-RESEARCH.md
@src/lib/utils.ts
@next.config.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create typed markdown pipeline</name>
  <files>package.json, src/lib/updates.ts, next.config.ts</files>
  <action>
1. Install dependencies:
   ```
   npm install gray-matter unified remark-parse remark-rehype rehype-stringify server-only
   ```

2. Create `src/lib/updates.ts` with the following:

   - Add `import 'server-only'` at the top to prevent client-side import.

   - Define the tag vocabulary as a const array and derive the union type:
     ```typescript
     export const UPDATE_TAGS = [
       'project-launch',
       'design-thinking',
       'business',
       'community',
       'learning',
     ] as const
     export type UpdateTag = (typeof UPDATE_TAGS)[number]
     ```

   - Define the `UpdateEntry` interface:
     ```typescript
     export interface UpdateEntry {
       slug: string       // derived from filename (strip date prefix and .md)
       title: string
       date: string       // YYYY-MM format
       tag: UpdateTag
       summary: string
       body: string       // rendered HTML from markdown body
     }
     ```

   - Create a `validateFrontmatter(data: Record<string, unknown>, filename: string): void` function that:
     - Checks `title` exists and is a non-empty string
     - Checks `date` exists and matches `/^\d{4}-\d{2}$/` regex
     - Checks `tag` exists and is included in `UPDATE_TAGS` (use type narrowing, NOT a cast)
     - Checks `summary` exists and is a non-empty string
     - Throws a descriptive error with the filename for any validation failure (e.g., `"Invalid tag 'foo' in 2025-06-codex-grove-launch.md. Valid tags: project-launch, design-thinking, business, community, learning"`)

   - Create a `parseUpdate(filename: string, raw: string): Promise<UpdateEntry>` function that:
     - Uses `matter(raw)` to extract `data` (frontmatter) and `content` (markdown body)
     - Calls `validateFrontmatter(data, filename)` -- throws on invalid
     - Uses the unified pipeline to convert `content` to HTML:
       ```typescript
       const result = await unified()
         .use(remarkParse)
         .use(remarkRehype)
         .use(rehypeStringify)
         .process(content)
       ```
     - Returns an `UpdateEntry` object with slug derived from filename (strip `.md` extension)

   - Create `getUpdates()` as an async function with the `"use cache"` directive:
     ```typescript
     export async function getUpdates(): Promise<UpdateEntry[]> {
       "use cache"
       cacheLife('days')
       // ...
     }
     ```
     - Uses `readdir` on `join(process.cwd(), 'src', 'content', 'updates')` to list `.md` files
     - Filters to only `.md` files
     - Reads each file with `readFile` (utf-8)
     - Calls `parseUpdate()` for each
     - Sorts by `date` descending (string comparison works for YYYY-MM format)
     - Returns the sorted array

   Import `cacheLife` from `'next/cache'`. Import `readdir` and `readFile` from `'node:fs/promises'`. Import `join` from `'node:path'`.

   IMPORTANT: Do NOT use `fs.readdirSync` or `fs.readFileSync` -- use the async versions.
   IMPORTANT: Do NOT install or use remark-frontmatter -- gray-matter handles frontmatter separately.
   IMPORTANT: The `"use cache"` directive goes INSIDE the function body as the first statement, not outside.

3. Update `next.config.ts` to enable `cacheComponents: true` in the experimental config:
   ```typescript
   const nextConfig: NextConfig = {
     cacheComponents: true,
     reactCompiler: true,
   }
   ```
   Note: In Next.js 16, `cacheComponents` is a top-level config option (not under `experimental`). This is required for the `"use cache"` directive to work.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no errors
    - `node -e "require.resolve('gray-matter')"` confirms gray-matter installed
    - `node -e "require.resolve('unified')"` confirms unified installed
    - Grep src/lib/updates.ts for `'server-only'`, `'use cache'`, `cacheLife`, `UPDATE_TAGS`, `UpdateEntry`, `UpdateTag`, `getUpdates`, `parseUpdate`, `validateFrontmatter`
  </verify>
  <done>
    - src/lib/updates.ts exports UpdateEntry interface, UpdateTag type, UPDATE_TAGS array, and getUpdates() function
    - Tag vocabulary is a TypeScript union derived from a const array (invalid tags cause compile errors in consuming code)
    - Validation function throws descriptive errors for missing/invalid frontmatter fields
    - getUpdates() uses "use cache" with cacheLife('days') for build-time caching
    - next.config.ts has cacheComponents: true
    - All dependencies installed (gray-matter, unified, remark-parse, remark-rehype, rehype-stringify, server-only)
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- All 6 packages appear in package.json dependencies
- src/lib/updates.ts contains "use cache", cacheLife, server-only import, UPDATE_TAGS, getUpdates
- next.config.ts contains cacheComponents: true
</verification>

<success_criteria>
The typed markdown pipeline exists and compiles. TypeScript enforces the UpdateEntry schema and tag vocabulary. The "use cache" directive is properly configured. The pipeline is ready to process markdown files once seed content is created in Plan 02.
</success_criteria>

<output>
After completion, create `.planning/phases/09-content-infrastructure/09-01-SUMMARY.md`
</output>
