---
phase: 11-entry-display
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/layout.tsx
  - src/lib/updates.ts
  - src/app/globals.css
  - package.json
autonomous: true

must_haves:
  truths:
    - "IBM Plex Mono font loads and renders in the browser"
    - "UpdateEntry type includes optional link field (url + label)"
    - "getUpdateBySlug(slug) returns a single entry with syntax-highlighted HTML body"
    - "getAdjacentEntries(slug) returns prev/next entry stubs"
    - "rehype-pretty-code transforms fenced code blocks into highlighted HTML"
  artifacts:
    - path: "src/app/layout.tsx"
      provides: "IBM Plex Mono font variable --font-mono"
      contains: "IBM_Plex_Mono"
    - path: "src/lib/updates.ts"
      provides: "UpdateEntry with link field, getUpdateBySlug, getAdjacentEntries, syntax highlighting pipeline"
      exports: ["getUpdateBySlug", "getAdjacentEntries"]
    - path: "src/app/globals.css"
      provides: "--font-mono in @theme"
      contains: "--font-mono"
  key_links:
    - from: "src/lib/updates.ts"
      to: "rehype-pretty-code"
      via: "unified pipeline .use(rehypePrettyCode)"
      pattern: "rehypePrettyCode"
    - from: "src/app/layout.tsx"
      to: "src/app/globals.css"
      via: "CSS variable --font-mono"
      pattern: "--font-mono"
---

<objective>
Install rehype-pretty-code + shiki, load IBM Plex Mono font, extend UpdateEntry with an optional link field, and add getUpdateBySlug() + getAdjacentEntries() utilities.

Purpose: Lay the data and tooling foundation that Plans 02 (entry list) and 03 (detail page) both depend on.
Output: Updated updates.ts with new exports, IBM Plex Mono available via --font-mono, syntax highlighting in the markdown pipeline.
</objective>

<execution_context>
@/Users/lucasalexander/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lucasalexander/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/lib/updates.ts
@src/app/layout.tsx
@src/app/globals.css
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install deps, load IBM Plex Mono font, register --font-mono</name>
  <files>package.json, src/app/layout.tsx, src/app/globals.css</files>
  <action>
1. Install rehype-pretty-code and shiki:
   `npm install rehype-pretty-code shiki`

2. In `src/app/layout.tsx`:
   - Import `IBM_Plex_Mono` from `next/font/google`
   - Configure: `const ibmPlexMono = IBM_Plex_Mono({ weight: ['400', '500'], subsets: ['latin'], variable: '--font-mono', display: 'swap' })`
   - Add `${ibmPlexMono.variable}` to the `<html>` className string alongside existing font variables

3. In `src/app/globals.css`, inside the `@theme` block:
   - Add `--font-mono: var(--font-mono), 'IBM Plex Mono', ui-monospace, monospace;` after the `--font-sketch` line
   - IMPORTANT: The Tailwind @theme --font-mono declaration connects the CSS variable from next/font to Tailwind's font-mono utility. The variable name collision is intentional -- Tailwind 4 resolves @theme values at build time.
  </action>
  <verify>
   - `npm run build` succeeds (no import errors)
   - Grep layout.tsx for `IBM_Plex_Mono` and `--font-mono`
   - Grep globals.css for `--font-mono`
  </verify>
  <done>IBM Plex Mono loads via next/font, --font-mono CSS variable available, rehype-pretty-code + shiki installed</done>
</task>

<task type="auto">
  <name>Task 2: Extend UpdateEntry type, add link field, create getUpdateBySlug + getAdjacentEntries, integrate syntax highlighting</name>
  <files>src/lib/updates.ts</files>
  <action>
1. Add optional `link` field to UpdateEntry interface:
   ```typescript
   link?: { url: string; label: string }
   ```

2. Update `validateFrontmatter` to handle optional link:
   - If `data.link` is present, validate it is an object with `url` (string, non-empty) and `label` (string, non-empty)
   - If `data.link` is absent/undefined, that is fine (optional)

3. Update `parseUpdate` to pass link through:
   - After existing field mapping, add: `link: data.link ? { url: data.link.url as string, label: data.link.label as string } : undefined`

4. Integrate rehype-pretty-code into the unified pipeline:
   - Import `rehypePrettyCode` from `rehype-pretty-code`
   - In the `parseUpdate` function, add `.use(rehypePrettyCode, { theme: 'github-dark-default', keepBackground: true })` BEFORE `.use(rehypeStringify)` and AFTER `.use(remarkRehype)`
   - IMPORTANT: rehype-pretty-code must come before rehypeStringify in the pipeline

5. Add `getUpdateBySlug` function:
   ```typescript
   export async function getUpdateBySlug(slug: string): Promise<UpdateEntry | null> {
     'use cache'
     cacheLife('days')
     const dir = join(process.cwd(), 'src', 'content', 'updates')
     try {
       const raw = await readFile(join(dir, `${slug}.md`), 'utf-8')
       return parseUpdate(`${slug}.md`, raw)
     } catch {
       return null
     }
   }
   ```

6. Add `getAdjacentEntries` function:
   ```typescript
   export async function getAdjacentEntries(slug: string): Promise<{
     prev: { slug: string; title: string } | null
     next: { slug: string; title: string } | null
   }> {
     const entries = await getUpdates()
     const index = entries.findIndex(e => e.slug === slug)
     if (index === -1) return { prev: null, next: null }
     return {
       prev: index > 0 ? { slug: entries[index - 1].slug, title: entries[index - 1].title } : null,
       next: index < entries.length - 1 ? { slug: entries[index + 1].slug, title: entries[index + 1].title } : null,
     }
   }
   ```

   Note: "prev" means the newer entry (index - 1, since sorted newest-first) and "next" means the older entry (index + 1). This matches chronological reading: prev goes toward newer, next goes toward older.
  </action>
  <verify>
   - `npx tsc --noEmit` passes
   - `npm run build` succeeds
   - Grep updates.ts for `getUpdateBySlug`, `getAdjacentEntries`, `rehypePrettyCode`, `link?`
  </verify>
  <done>UpdateEntry has optional link field, getUpdateBySlug returns single entry, getAdjacentEntries returns prev/next stubs, syntax highlighting integrated into pipeline</done>
</task>

</tasks>

<verification>
- `npm run build` completes without errors
- `npx tsc --noEmit` passes
- IBM Plex Mono variable present in layout.tsx and globals.css
- getUpdateBySlug and getAdjacentEntries exported from updates.ts
- rehype-pretty-code in the unified pipeline
- UpdateEntry interface includes optional link field
</verification>

<success_criteria>
- IBM Plex Mono font is loaded and available as font-mono utility
- rehype-pretty-code + shiki installed and integrated into markdown pipeline
- UpdateEntry type includes optional link: { url: string; label: string }
- getUpdateBySlug(slug) returns a single UpdateEntry or null
- getAdjacentEntries(slug) returns { prev, next } with slug + title
- Build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/11-entry-display/11-01-SUMMARY.md`
</output>
