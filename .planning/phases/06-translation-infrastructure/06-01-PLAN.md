---
phase: 06-translation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/i18n.d.ts
  - messages/en.json
  - messages/fr.json
autonomous: true

must_haves:
  truths:
    - "TypeScript autocomplete suggests translation keys when typing t('...')"
    - "TypeScript compilation fails if a misspelled key is used"
    - "en.json and fr.json have identical key structures"
  artifacts:
    - path: "src/types/i18n.d.ts"
      provides: "TranslationKey union type from NestedKeyOf utility"
      contains: "NestedKeyOf"
    - path: "messages/en.json"
      provides: "English translations organized by namespace"
      min_lines: 20
    - path: "messages/fr.json"
      provides: "French translations matching en.json structure"
      min_lines: 20
  key_links:
    - from: "src/types/i18n.d.ts"
      to: "messages/en.json"
      via: "import type"
      pattern: "import.*en\\.json"
---

<objective>
Create TypeScript type definitions for translation keys and initial translation JSON files for English and French.

Purpose: Establish the type-safe foundation that enables compile-time validation of translation keys. Without this, the LocaleProvider cannot provide type-safe t() function.

Output: src/types/i18n.d.ts with NestedKeyOf utility type, messages/en.json and messages/fr.json with matching structure containing placeholder strings for all UI sections.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-translation-infrastructure/06-RESEARCH.md
@src/types/project.ts
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TypeScript type definitions for translation keys</name>
  <files>src/types/i18n.d.ts</files>
  <action>
Create src/types/i18n.d.ts with:

1. Import the en.json file using `import type en from '../../messages/en.json'`
   - Note: File doesn't exist yet, but TypeScript will resolve once created

2. Create NestedKeyOf utility type that generates a union of all dot-notation paths:
```typescript
type NestedKeyOf<T, Prefix extends string = ''> = T extends object
  ? {
      [K in keyof T & string]: T[K] extends object
        ? NestedKeyOf<T[K], `${Prefix}${K}.`>
        : `${Prefix}${K}`
    }[keyof T & string]
  : never
```

3. Export TranslationKey as `NestedKeyOf<typeof en>`

4. Export Messages type as `typeof en` for optional structure validation

The result: When t('hero.title') is called, TypeScript validates 'hero.title' exists as a key in en.json.
  </action>
  <verify>
TypeScript processes the file without errors (npx tsc --noEmit may show en.json not found yet - this is expected).
File exists at src/types/i18n.d.ts.
  </verify>
  <done>
src/types/i18n.d.ts exists with NestedKeyOf utility type and TranslationKey export.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create translation JSON files with initial structure</name>
  <files>messages/en.json, messages/fr.json</files>
  <action>
Create messages/ directory at project root (not src/).

Create messages/en.json with nested structure matching existing UI sections:
```json
{
  "nav": {
    "services": "Services",
    "projects": "Projects",
    "contact": "Contact"
  },
  "hero": {
    "title": "Been burned by developers before?",
    "subtitle": "I get it. You hired someone who promised the world..."
  },
  "services": {
    "title": "What I Do",
    "placeholder": "Services content placeholder"
  },
  "projects": {
    "title": "Work",
    "placeholder": "Projects content placeholder"
  },
  "contact": {
    "title": "Let's Talk",
    "name_label": "Name",
    "name_placeholder": "Your name",
    "email_label": "Email",
    "email_placeholder": "your@email.com",
    "message_label": "Message",
    "message_placeholder": "What's on your mind?",
    "submit": "Send It",
    "sending": "Sending...",
    "success": "Sent! I'll be in touch soon.",
    "error": "Something went wrong. Please try again."
  },
  "footer": {
    "copyright": "Civix Solutions",
    "tagline": "Boutique frontend development"
  },
  "cursor": {
    "thats_me": "That's me!",
    "what_ill_do": "What I'll Do",
    "what_ive_done": "What I've Done"
  }
}
```

Create messages/fr.json with identical structure and French translations:
- Use placeholder French text for now (Phase 8 will finalize translations)
- Keep structure exactly matching en.json
- Example: "nav.services" -> "Services", "nav.projects" -> "Projets"

Important: Both files MUST have identical keys. Only string values differ.
  </action>
  <verify>
Both files exist: `ls messages/en.json messages/fr.json`
Valid JSON: `node -e "require('./messages/en.json'); require('./messages/fr.json'); console.log('Valid JSON')"`
  </verify>
  <done>
messages/en.json and messages/fr.json exist with matching nested key structures.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `npx tsc --noEmit` passes without errors (or only unrelated errors)
2. Both JSON files parse successfully
3. Type file imports en.json and exports TranslationKey
</verification>

<success_criteria>
- TranslationKey type exists and is derived from en.json structure
- en.json contains all UI section namespaces (nav, hero, services, projects, contact, footer, cursor)
- fr.json structure exactly matches en.json (same keys, different values)
- TypeScript will provide autocomplete for translation keys once LocaleProvider is built
</success_criteria>

<output>
After completion, create `.planning/phases/06-translation-infrastructure/06-01-SUMMARY.md`
</output>
